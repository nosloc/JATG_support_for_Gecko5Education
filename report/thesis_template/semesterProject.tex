%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EPFL report package, main thesis file
% Goal: provide formatting for theses and project reports
% Author: Mathias Payer <mathias.payer@epfl.ch>
%
% To avoid any implication, this template is released into the
% public domain / CC0, whatever is most convenient for the author
% using this template.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{report}
% Options: MScThesis, BScThesis, MScProject, BScProject
\usepackage[MScProject,lablogo]{EPFLreport}
\usepackage{xspace}

\title{JTAG support \\for Gecko5Education board}
\author{Antoine Colson}
\supervisor{Prof. Ties Jan Henderikus Kluter}

\newcommand{\boardName}{Gecko5Education \xspace}

\begin{document}
\maketitle
% \makededication
% \makeacks

% \begin{abstract}
% The \sysname tool enables lateral decomposition of a multi-dimensional
% flux compensator along the timing and space axes.

% The abstract serves as an executive summary of your project.
% Your abstract should cover at least the following topics, 1-2 sentences for
% each: what area you are in, the problem you focus on, why existing work is
% insufficient, what the high-level intuition of your work is, maybe a neat
% design or implementation decision, and key results of your evaluation.
% \end{abstract}

% \begin{frenchabstract}
% For a doctoral thesis, you have to provide a French translation of the
% English abstract. For other projects this is optional.
% \end{frenchabstract}

\maketoc

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

    This project focuses on implementing and testing robust JTAG (Joint Test Action Group) communication 
and control on the \boardName board. The goal is to develop 
low-level infrastructure that enables JTAG-based access to internal system components, 
such as memory and peripherals, paving the way for advanced debugging, testing, and programming capabilities.
Several challenges arose from this project statement.
First, the board was designed exclusively for educational use at EPFL, and as a result, it lacks official documentation which leaves its internals largely unexplored in this context. 
Second, no prior work had been done on enabling JTAG access for the \boardName board; existing references focuse on different boards or architectures. 
Finally, the built-in JTAG interface is extremely minimalistic, exposing only the bare features required by the standard, with only little support for custom extensions or advanced control.\\

To address these challenges, the project was divided into two main milestones: 

\begin{itemize}
    \item Establish basics communication via the JTAG interface and demonstrate control by using 
    on-board RGB LEDs.
    \item Extend the JTA interface to suppoort memory accesses and peripherals control, by providing read and write
    operations to any component on the bus architecture.
\end{itemize}

In summary, this project aimed to transform the previously underutilized JTAG interface of the \boardName board into a powerful low-level communication path
that can later be used by EPFL students. 
Both milestones were successfully completed: reliable communication with the board was achieved, 
and the interface was extended to provide full memory and peripheral access. As a result, 
software can now interact with the board through a high-level abstraction of the JTAG interface, hiding much of the underlying complexity.
The remainder of this report details the background of the project, the design decisions made, the concrete implementation and the evaluation of the updated JTAG interface.


%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%

This chapter provides the necessary context for the project.  
It introduces the \boardName board, essential FPGA concepts,  
the board’s initial architecture related to this project, and the JTAG protocol.  
It also covers the open-source toolchain used for development,  
simulation, and debugging.  

\section{The \boardName Board}
\label{sec:board}

The \boardName board is an FPGA development platform primarily  
used for teaching digital systems and computer architecture at EPFL.  
It is designed to give students hands-on experience and features  
a Lattice ECP5 FPGA at its core.  
The board also includes various peripherals suitable for system-on-chip experimentation,  
such as DRAM memory blocks, general-purpose I/Os (GPIOs) like push buttons and switches,  
an RGB LED matrix, and a UART interface for serial communication.  

Although the board provides a JTAG port through a USB-C connector,  
it was previously unused due to its minimal implementation and  
the availability of UART for communication.  

\section{FPGA Basics}

As mentioned in Section~\ref{sec:board}, the \boardName board is built around a Lattice ECP5 FPGA.  
Unlike CPUs that execute software, FPGAs are reconfigurable hardware platforms  
used to implement digital logic circuits.  
They are programmed using hardware description languages (HDLs);  
in this project, Verilog is used to describe the hardware's structure and behavior.  
The HDL code is then synthesized, placed, and routed to produce a bitstream,  
which is loaded into the FPGA.  

In this project, the FPGA is used to enhance an existing microcontroller-based architecture  
by adding components for JTAG support.  

\section{Toolchain}
\label{sec:toolchain}

The project uses the open-source \texttt{oss-cad-suite},  
a comprehensive set of tools for FPGA development.  
Icarus Verilog is used for simulation,  
and GTKWave is employed for waveform visualization.  
Yosys and nextpnr-ecp5 handle synthesis and placement,  
while ecppack generates the bitstream.  
The design is then loaded onto the FPGA using openFPGALoader.  

Additionally, \texttt{OpenOCD} (Open On-Chip Debugger) is used  
to interact with the JTAG interface.  
It provides a telnet-accessible environment to send low-level JTAG commands,  
making it possible to control TAP states and directly drive input signals.  

\section{Initial System Architecture}

The default system architecture on the board is based on an OpenRISC microprocessor,  
implementing the OpenRISC 1000 ISA in a 5-stage pipelined configuration.  
It is connected to other modules via a 32-bit shared bus.  
The default setup includes a UART module, an SDRAM memory controller,  
a camera interface, and various GPIO components.  

All modules are interconnected through the shared bus,  
which is designed to be easily extensible—  
an essential feature leveraged in the second milestone of this project.  

However, for the first milestone,  
the JTAG interface is used only to control the RGB LEDs,  
which are directly mapped to GPIOs.  

\section{JTAG Protocol}
\label{sec:JTAG}

The JTAG protocol is the core focus of this project.  
Defined by the IEEE 1149.1 standard,  
JTAG (Joint Test Action Group) was introduced in the 1990s  
to facilitate testing and debugging of printed circuit boards.  
It uses boundary-scan techniques to check inter-chip connections  
without requiring physical access to individual pins.  

Today, JTAG is widely used for in-system programming, secure provisioning,  
and system-level debugging in embedded systems.  

The interface includes four required signals and one optional:  

\begin{itemize}
    \item \textbf{TDI (Test Data In)} — Serial input line.  
    \item \textbf{TDO (Test Data Out)} — Serial output line.  
    \item \textbf{TCK (Test Clock)} — Synchronizes data shifting.  
    \item \textbf{TMS (Test Mode Select)} — Drives the JTAG finite state machine.  
    \item \textbf{TRST (Test Reset)} — Optional asynchronous reset line.  
\end{itemize}

JTAG communication is governed by the TAP (Test Access Port) controller,  
which operates as a finite state machine.  
Key states include:  

\begin{itemize}
    \item \textbf{Test-Logic Reset} — Resets the TAP controller.  
    \item \textbf{Run-Test/Idle} — Wait state for idle periods.  
    \item \textbf{Capture-IR / Shift-IR / Update-IR} — Instruction register operations.  
    \item \textbf{Capture-DR / Shift-DR / Update-DR} — Data register operations.  
\end{itemize}

The TAP state transitions are determined by the TMS input on rising edges of TCK.  
By controlling TMS, TDI, and TCK, users can navigate the state machine,  
shift in instructions, and exchange data.  

Because JTAG relies on shift registers, it supports bidirectional communication:  
data can be shifted in via TDI and read out via TDO simultaneously.  
In this project, this mechanism is used to control LEDs  
and access memory and peripheral modules on the \boardName board.  


%%%%%%%%%%%%%%%%
\chapter{Design}
%%%%%%%%%%%%%%%%
This chapter describes the design choices and mechanisms implemented to enable 
JTAG-based control on the \boardName board.  
We first present the existing JTAGG interface used throughout the whole project then the design for the milestone 1, which focuses on controlling the RGB LEDs.  
Then we discuss the design for the milestone 2, which extends the JTAG interface to support memory and peripheral access.  

\section{JTAG Interface Block: JTAGG}

On the \boardName board, the JTAG interface is implemented using a Lattice ECP5 FPGA. This FPGA includes a built-in JTAG interface block that 
can be instantiated and used in the desuign. This block is responsible for handling the JTAG protocol and provides the necessary signals for communication,
while respecting the standard definition of JTAG.
For the Lattice ECP5, the existing JATG interface block is called \texttt{JTAGG}, and provides the minimum required signals and 
functionnalities to implement the JTAG protocol and letting the user defining two custom instructions \texttt{ER1} and \texttt{ER2}.
Hence the JTAGG block provides the TDI, TDO, TCK, and TMS signals and is control by a TAP controller as described in Section~\ref{sec:JTAG}.
On top of that it also provudes signals to let the user define two custom instructions, they are active when the values \texttt{0x32} and \texttt{0x38} are shifted into the instruction register respectively.
The JATGG block therefore provides set of pins that can be used to create those two free instructions.
Here is an explanation of the signals provided by the JTAGG block:

\begin{itemize}
    \item \textbf{Inputs:}
    \begin{itemize}
        \item \textbf{JTDO1}: If \texttt{ER1} instruction is shifted into the JTAG instruction register, 
        TDO output will come from \texttt{JTDO1}.
        
        \item \textbf{JTDO2}: If \texttt{ER2} instruction is shifted into the JTAG instruction register, 
        TDO output will come from \texttt{JTDO2}.
        
        \item \textbf{TCK*}: Clock used to clock the registers and the TAP controller, 
        \emph{connected to the actual JTAG pins}.
        
        \item \textbf{TMS*}: Controls state switching for the TAP controller, 
        \emph{connected to the actual JTAG pins}.
        
        \item \textbf{TDI*}: Test Data Input, 
        \emph{connected to the actual JTAG pins}.
    \end{itemize}

    \item \textbf{Outputs:}
    \begin{itemize}
        \item \textbf{TDO*}: Test Data Output, 
        \emph{connected to the actual JTAG pins}.
        
        \item \textbf{JTCK}: Signal derived from \texttt{TCK} and routed to custom instruction blocks.
        
        \item \textbf{JTDI}: Signal derived from \texttt{TDI} and routed to custom instruction blocks.
        
        \item \textbf{JRTI1}: Goes high when the TAP controller is in \texttt{Run-Test/Idle} state 
        and \texttt{ER1} is the current instruction.
        
        \item \textbf{JRTI2}: Goes high when the TAP controller is in \texttt{Run-Test/Idle} state 
        and \texttt{ER2} is the current instruction.
        
        \item \textbf{JSHIFT}: Goes high when the TAP controller is in the \texttt{Shift-DR} state.
        
        \item \textbf{JUPDATE}: Goes high when the TAP controller is in the \texttt{Update-DR} state.
        
        \item \textbf{JRSNT}: \emph{(Active low)}. Goes low when the TAP controller is in the 
        \texttt{Test-Logic-Reset} state.
        
        \item \textbf{JCE1}: Goes high when the TAP controller is in \texttt{Capture-DR} or 
        \texttt{Shift-DR} states and \texttt{ER1} is selected.

        \item \textbf{JCE2}: Goes high when the TAP controller is in \texttt{Capture-DR} or 
        \texttt{Shift-DR} states and \texttt{ER2} is selected.
    \end{itemize}
\end{itemize}

Using those signals, we can create two custom instructions blocks that can be aware of the main TAP controller state and if the custom instruction is selected.
For example to send data to ER1, we can first shift the instruction \texttt{ER1:0x32} into the instruction register, then we can shift the data we want to send 
to the TDI input that is directly connected to the JTDI output of the JTAGG block used by custom instructions block as serial data in input.

The JTAGG block is therefore a simplistic but powerful tool that allows us to create custom instructions and control the TAP controller state.\\

\section{Milestone 1: RGB LED Control}

This milestone consists of a simple JTAG interface that allows the user to control the RGB LEDs on the \boardName board by communicating with the JTAG interface.
The goal of it is to desmonstrate the feasibility of the JTAG interface and to provide a proof of concept for the second milestone, by 
letting the user decide the colors of a selected column in the RGB LED matrix.

We first presented the existing JTAG interface block available in Lattice ECP5 FPGAs 
and shortly explained how it is leveraged to build the custom communication system.  
Now we discuss the design of an Intellectual Property Core (IP Core) that is used between the JTAG interface and the
RGB LEDs.  


\subsection{The Iintellectual Property Core (IP Core)}

The IP core is a Verilog module directly interfaced with the JTAGG component. 
It is responsible for interpreting signals related to custom JTAG instructions and translating them into concrete actions on the board.

In the context of this milestone, the IP core’s role is to control a 12x10 RGB LED matrix.
To achieve this, the core uses two custom instructions—ER1 and ER2—each handling a different aspect of LED control: color values and column selection, respectively.

The IP core is structured around the following design principles:

The IP core is organized in a modular fashion, containing two independent submodules—
Chain1 and Chain2—each corresponding to one of the custom JTAG instructions. Chain1,
associated with instruction 0x32, manages the LED colors by maintaining a 30-bit register
(3 bits per color for each of the 10 LEDs in a column), with its output directly driving the
LED matrix. Chain2, linked to instruction 0x38, is responsible for selecting which column
of the matrix is addressed, outputting a 4-bit signal to represent one of the 12 columns.
Both submodules receive control signals from the JTAGG module (as described in
Section~\ref{sec:JTAG}), while the IP core simpy instantiate both chains and drives input signal correspondingly.

This design allows the IP core to act as a bridge between user-issued JTAG commands and
low-level hardware behavior. It provides a clean, modular way to interpret and apply JTAG
instructions to specific hardware operations on the board.

\subsection{How to communicate with the board through JTAG ?} 

Now that we have a clear understanding of the JTAGG block and the IP core, we can discuss how to concretely communicate with the board through JTAG.
First, we update the \texttt{.lpf} file to map the output signals of the two chains to the corresponding pins of the RGB LED matrix.
Second the updated design (including the Ip core and the JTAGG block) is synthesized and a bitstream is generated using tools explained in \ref{sec:toolchain}.
Once our design is loaded into the FPGA, we can use OpenOCD to communicate with the board through JTAG.

Once OpenOCD is started using a board specific configuration file, it runs a local telnet server on port 4444.
We can the connect to this server and use the large set of commands provided to interact with the board.
Although the set of commands is large, we will only focus on the low JTAG related commands that are used during this project.
The most important commands are:
\begin{itemize}
    \item \verb|irscan <tap_name> <instruction>|: This command shifts the instruction into the instruction register of the TAP controller (returns in RUN/TEST-IDLE state).
    \item \verb|drscan <tap_name> <size> <data>|: This command shifts the first size bits of the data into the data register corresponding (returns in RUN/TEST-IDLE state).
    to the loaded instruction.
    \item \verb|pathmove <tap_state_name>|: This command moves the TAP controller to the specified state.
    \item \verb|runtest <nb_cycles>|: This command runs the TAP controller for nb\_cycles clock cycles.
\end{itemize}

To control the RGB LEDS, we can thereore load either the \texttt{ER1} or \texttt{ER2} instruction into the instruction register using the \texttt{irscan} command.
Then we can use the \texttt{drscan} command to shift the either the color values or the column selection into the data register.
Finally, if needed we can use the \texttt{pathmove reset} command to reset the whole TAP controller.


Introduce and discuss the design decisions that you made during this project.
Highlight why individual decisions are important and/or necessary. Discuss
how the design fits together.

This section is usually 5-10 pages.


%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%

The implementation covers some of the implementation details of your project.
This is not intended to be a low level description of every line of code that
you wrote but covers the implementation aspects of the projects.

This section is usually 3-5 pages.


%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
%%%%%%%%%%%%%%%%%%%%

In the evaluation you convince the reader that your design works as intended.
Describe the evaluation setup, the designed experiments, and how the
experiments showcase the individual points you want to prove.

This section is usually 5-10 pages.


%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related Work}
%%%%%%%%%%%%%%%%%%%%%%

The related work section covers closely related work. Here you can highlight
the related work, how it solved the problem, and why it solved a different
problem. Do not play down the importance of related work, all of these
systems have been published and evaluated! Say what is different and how
you overcome some of the weaknesses of related work by discussing the 
trade-offs. Stay positive!

This section is usually 3-5 pages.


%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%

In the conclusion you repeat the main result and finalize the discussion of
your project. Mention the core results and why as well as how your system
advances the status quo.

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography

% Appendices are optional
% \appendix
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{How to make a transmogrifier}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% In case you ever need an (optional) appendix.
%
% You need the following items:
% \begin{itemize}
% \item A box
% \item Crayons
% \item A self-aware 5-year old
% \end{itemize}

\end{document}